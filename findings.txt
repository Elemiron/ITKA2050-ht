## Harjoitustyöraportti

Palauttaja: Elena Mironenko, elemiron
Pisteitä yhteensä: 2pt (?) 

## Ongelma 1
Tyyppi:   Polkuinjektio
Sijainti: delete_file()
Kuvaus:

Aliohjelmassa delete_file ei tarkasteta käyttäjän syöttämää polkua
millään tavalla. Tämä mahdollistaa sen, että käyttäjä tuhoaa minkä
tahansa tiedoston, esimerkiksi toisen käyttäjän tiedoston tai vaikkapa
jonkin järjestelmätiedoston. 

### Esimerkkihyökkäys: 

1) Kirjaudu sisään käyttäjänä "sam".
2) Tee pyyntö /delete_file?file=../sue/tiedosto.txt
3) Tulos: Suen tiedosto tuhotaan

### Korjaus:

Commit: <git hash>

Paikka, johon korjaus on tehty, on kommentoitu koodiin. Korjasin tämän kohdan
laittamalla checkPath(path)-funktion delete_file()-funktioon ennen ehtolauseita.
Korjaus toimii, koska jos yritetään laittaa osoiteriville "../" tulee virheilmoitus
eikä mitään poisteta.


### Pisteet(2pt)

1pt vian löytämisestä
1pt vian korjaamisesta


...


## Ongelma 2
Tyyppi:   Shell-injektio
Sijainti: checkerLoop(queue)
Kuvaus:	  

Aliohjelmassa avataan komentotulkki, jonka kautta avataan tiedosto.
Aliohjelmassa tarkastetaan vain, että tiedostossa on "JPG" tai "PNG", 
mutta se ei estä putkittamista tiedoston nimessä. Se ei myöskään
estä tälläisen tiedoston lataamista ja jakamista sovelluksessa.

### Esimerkkihyökkäys: 

1) Kirjaudu sisään käyttäjänä "sam".
2) Lataa tietokoneelta tiedosto, jonka nimi on "kissa.jpg;rm *"
3) Tulos: Koko ohjelma lakkaa olemasta. Kaikki tiedostot hakemistossa
CourseWork poistuu.

### Korjaus:

Commit: <git hash>

Paikka, johon korjaus on tehty, on kommentoitu koodiin. Korjasin tämän
kohdan laittamalla komennot taulukkoon ja poistamalla ehdon "shell=True".
Korjaus toimii, koska tiedostonimissä olevia putkituksia ei enään suoriteta
komentotulkissa. Vikatyyppi on myös eliminoitu, sillä shell-injektiota ei 
enään pysty tapahtumaan.

### Pisteet(3pt)

1pt vian löytämisestä
1pt vian korjaamisesta
1pt vikatyypin eliminoimisesta


...


## Ongelma 3
Tyyppi:   Eväste-haavoittuvuus
Sijainti: login()
Kuvaus:

Ohjelmalla ei ole väliä, mistä pyynnöt palvelimelle tulevat. Curlia ja oikeaa 
evästettä käyttämällä pääsee tekemään sovelluksessa mitä tahansa kenä tahansa käyttäjänä.
Curlia käyttäessä salasanaa ei kysytä.

### Esimerkkihyökkäys: 

1) Tee palvelimelle pyyntö komentotulkilla: 
curl 'http://localhost:5000/delete_file?file=*' -H 'Cookie: username=sam'
2) Tulos: kaikki käyttäjän sam tiedostot tuhoutuvat

### Korjaus:

Commit: <git hash>

Korjaus on tehty yksinkertaisesti laittamalla yhdistelmä käyttäjätunnuksesta ja 
salasanasta cookieen. Oikeasti salasanaa ei saisi laittaa paljaana cookieseen, vaan 
se pitäisi hashata jollakin tavalla, mutta tässä ei esimerkin yksinkertaisuuden
vuoksi ole sitä tehty. Nyt kuitenkaan ei päästä tekemään muista lähteistä, kuin käytössä
olevasta selaimesta kenä tahansa käyttäjänä tietämättä salasanaa.
Korjaus toimii, koska salasanaa pitää aina käyttää, kun halutaan yhteys jonkin käyttäjän
tiedostoihin. Korjaus on tehty kaikkiin kohtiin, joissa kysytään cookieta 'username'. Sen
sijaan, että aliohjelmissa kysytään username cookieta autentisoimaan käyttäjää, käytetään
username:password cookieta.

### Pisteet(2pt)

1pt vian löytämisestä
1pt vian korjaamisesta


...
Vähän lisää edelliseen..
...

## Ongelma 4
Tyyppi:  Eväste-haavoittuvuus
Sijainti: logout() ja login()

rivi 76  resp.set_cookie('username', username)
rivi 120  resp.set_cookie('username', expires=0)


Kuvaus:
Evästeen HttpOnly on oletusarvoisesti asetettu arvoon False eikä erikseen laitettu True. 
False tarkoittaa sitä, että käyttäjä voi tehdä sivustojen välisiä komentosarjahyökkäyksiä, joissa hyökkääjä pääsee käsiksi arkaluontoisiin istuntotietoihin ja käyttää näitä tietoja huijatakseen laillisia verkkopohjaisia ​​sovelluksia paljastamaan luottamuksellisia tietoja tai hyväksymään laittomia pyyntöjä. Myöskään ei asetettu secure attribuuttia, jolloin hyökkääjä saattaa pystyä sieppaamaan kyseisen evästeen. Kun hyökkääjällä on nämä tiedot, hän voi mahdollisesti esiintyä käyttäjänä, päästä käsiksi luottamuksellisiin tietoihin ja suorittaa toimintoja, joihin heillä ei normaalisti olisi lupaa.


### Esimerkkihyökkäys:



### Korjaus:

Commit: <git hash>

resp = Response(status=301, headers={"location": url_for('index')})
resp.set_cookie('forget_sid', session.id,
    max_age=60*60*48,
    httponly=True,
    secure=app.config.get("HTTPS"))
 return resp
 
 

### Pisteet(2pt)
1pt vian löytämisestä
1pt vian korjaamisesta


...


## Ongelma 5
Tyyppi:   XSS
Sijainti: checkerLoop(queue)
Kuvaus:

Ohjelmassa tarkistetaan vain, onko tiedoston sisältö kuvadataa, mutta se ei suojaa
HTML-injektiolta kuvien nimissä.

### Esimerkkihyökkäys:

1) Vaihda kuvan "kissa.jpg" nimeksi sopiva HTML-injektio, esim. <button onmouseover="alert(1)">
2) Lataa kuva palveluun.
3) Kuva poistetaan, mutta se tulee poistettujen kuvien listaan ja voi rikkoa koko palvelun.

### Korjaus:

Commit: <git hash>

Korjaus on tehty yksinkertaisesti niin, että tiedostoja, joissa on merkki '<' ei voi  
ladata. Korjaus toimii, koska nyt ei pystytä tekemään tiedostonimiä, joissa  
XSS olisi mahdollista, sillä aloittavaa tagiä ei voida käyttää. 

### Pisteet(2pt)

1pt vian löytämisestä
1pt vian korjaamisesta


...


## Ongelma 6
Tyyppi:   Polkuinjektio

Sijainti: 

rivi 170  os.remove(path + '/' + file)
rivi 180  os.remove(configuration['web_root'] + "/" + user_file)
rivi 218  thefile.save(target_path)
rivi 252  return send_file(shared)
rivi 256  return send_file(path)


Kuvaus:
Mahdollisuus käyttää ja manipuloida mielivaltaista polkua johtaa haavoittuvuuksiin, kun ohjelmaa ajetaan sellaisilla oikeuksilla, joita polun tarjoavalla käyttäjällä ei pitäisi olla. Sivusto, jossa on polun läpikulkuhaavoittuvuus, antaisi käyttäjien pääsyn sitä isännöivän palvelimen arkaluonteisiin tiedostoihin. Eli antaa hyökkääjän saada tietoa kansiorakenteesta tai lukea järjestelmän arkaluonteisten tiedostojen sisältöä.



### Esimerkkihyökkäys:



### Korjaus:

Commit: <git hash>

if request.method == "POST":
    try:
        f = request.files['file']
        filename = secure_filename(f.filename)
        f.save(filename)
        with open(filename, "r", encoding="utf-8") as f:
            success, errors = words_validate(f.read())
  


task_type = 1

if len(request.files) == 0:

    task_type = 1

task_type = 2
upload_src = request.files['file']
filename = str(int(time.time())) + '_' + secure_filename(upload_src.filename)
filepath = 'uploads/' + filename
upload_src.save(filepath)



### Pisteet(2pt)
1pt vian löytämisestä
1pt vian korjaamisesta


...


## Ongelma 7
Tyyppi: Uudelleenohjaus
Sijainti: upload_file()

rivi 205  return redirect(request.url)
rivi 209  return redirect(request.url)
	
Kuvaus:
Puhdistamaton syöttö pyynnön URL-osoitteesta siirtyy kohtaan flask.redirect , jossa sitä käytetään URL-osoitteena käyttäjän uudelleenohjaamiseen. Tämä voi johtaa Open Redirect -haavoittuvuuteen. Jos resurssi on esimerkiksi siirtynyt uuteen paikkaan, URL-uudelleenohjaus voi siirtää käyttäjän kyseiseen sijaintiin virheilmoituksen näyttämisen sijaan. Tätä kykyä voidaan kuitenkin hyödyntää sosiaalisen manipuloinnin avulla, mikä huijaa käyttäjät uskomaan, että he käyttävät yhtä sivustoa, kun todellisuudessa hänet ohjataan vaaralliselle sivustolle, kuten tietojenkalastelusivustolle. 



### Esimerkkihyökkäys:



### Korjaus:

Commit: <git hash>

Vähintään pitäisi ilmoittaa että käyttäjä on siirtymässä toiselle sivustolle.

@app.route('/<reponame>/comment', methods=['POST'])
def comment(reponame):
    comment = request.form.get('comment')
    add_comment(reponame, comment)
    return redirect(url_for('heso', reponame=reponame))

  
### Pisteet(1pt)
1pt vian löytämisestä

------------------------------------------------------------------------------------------------------------------
